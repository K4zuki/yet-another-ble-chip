
## mbed^TM^プラットフォームを利用する
### ~~ｴｪｪｪｪﾝﾍﾞｯﾄﾞ!~~ mbed^TM^とは
mbedは、ARM社が提唱しているARM Cortex−Mコアを使った各社のマイクロコントローラを１つの共通したライブラリ群で扱うためのプラットフォームです。
ユーザプログラムはクラウド上のIDE環境を用い、C++で記述されます。
mbed環境に対応するボード群をPlatformsと呼び、共通ライブラリが適用できます。
他にもComponentsと呼ばれる、予めライブラリが用意された部品群があります。

### イカ醤油ポッポ焼きの解説
イカ醤油ポッポ焼き（Ika Shouyu Poppo-yaki a.k.a. *ISP*）は@tedd_okano氏が
ツイッターのノリに任せて[^2_3_1] 作(ってしま)ったプログラム[^2_3_2] です。
LPCマイコンシリーズ（の一部）向けのライタプログラムで、
ターゲットデバイス用コンパイル済バイナリを、mbed LPC1768/11U24 からUARTを使って書き込みます。  
mbed LPC1768/11U24 の2品種だけはパソコンからUSBメモリに見える
"LocalFileSystem"機能を備えています。
イカ醤油ポッポ焼きはmbed起動(リセット)時に予め設定されたファイル名のバイナリが
LocalFileSystem内に存在するか確認し、確認されるとそのバイナリを
シリアル通信で書き込みます。この時の書き込みプロトコルはNXP社マイコン
(LPCマイコン)特有のものなので、そのまま`DA14580`に適用することはできません。
そこで、イカ醤油ポッポ焼きっぽく動作するmbedプログラムを`DA14580`向けに実装します。

### イカ醤油もどきを実装する
#### DA14580のブート手順 {.unnumbered}

_この部分の詳細は **AN-B-001 DA1458x Booting from serial interfaces[^0.3.1]** を参照してください_

`DA14580`は、電源リセットがかかるとまずOTPに書き込まれたプログラムがあるかどうかを
特定のアドレスを読むことで確認します。この時にプログラムが書き込まれていない=OTPが空だと
判定された場合、`DA14580`は以下の順序で外部シリアルインターフェースから
プログラムのロードを試みます：

1. 外部SPIマスタ（2つのピン組み合わせ）
1. **UART(9600/57600/115200 baud、4つのピン組み合わせ)**
1. SPIスレーブ（SPIフラッシュメモリなど）
1. I2Cスレーブ（I2C EEPROMメモリなど、4つのピン組み合わせ）  
1. これらすべてが失敗した場合はSWDデバッガからの入力を待ちます。

#### UARTブート仕様 {.unnumbered}
この後元祖イカ醤油と同様にUARTシリアル通信でコンパイル済バイナリをロードする
方法を示します。あとで必要なのでまずはUARTブートの仕様を書いておきます。  
使用されるピンはPORT0の8ピンで、P0_0から2ピンずつペアになります。

Table:  UARTブートのピン組み合わせ

+---+--------+--------+----------+
|   | 580 TX | 580 RX | BaudRate |
+===+========+========+==========+
| 1 |  P0_0  |  P0_1  |  57600   |
+---+--------+--------+----------+
| 2 |  P0_2  |  P0_3  |  115200  |
+---+--------+--------+----------+
| 3 |  P0_4  |  P0_5  |  57600   |
+---+--------+--------+----------+
| 4 |  P0_6  |  P0_7  |   9600   |
+---+--------+--------+----------+

すべての組み合わせについて、
8ビット、パリティなし、1ストップビット（8N1）です。

#### UARTブートプロトコル{.unnumbered}
UARTでのブートにはXMODEMによく似た手順を用います（残念ながら筆者はXMODEMを
よく知りませんが、各予約語がXMODEMと一致するのは見つけられました）。
mbed LPC1768のp9/p10に`DA14580`のP0_4/P0_5を接続しておきます。

Table:  UARTブートプロトコル

+------+-------------------+------------------+---------------------------------+
| step | 580 P0_4/mbed p10 | 580 P0_5/mbed p9 | comment                         |
+======+===================+==================+=================================+
|  0   | STX = 0x02        |                  | Start TX, STX                   |
+------+-------------------+------------------+---------------------------------+
|  1   |                   | SOH = 0x01       | Start of Header, SOH            |
+------+-------------------+------------------+---------------------------------+
|  2   |                   | LEN_LSB          | バイナリサイズ(LSB)             |
+------+-------------------+------------------+---------------------------------+
|  3   |                   | LEN_MSB          | バイナリサイズ(MSB)             |
+------+-------------------+------------------+---------------------------------+
|  4   | ACK = 0x06 or     |                  |                                 |
|      | NACK = 0x15       |                  | ACKnowledged / Not ACKnowledged |
+------+-------------------+------------------+---------------------------------+
| 5~N  |                   | バイナリデータ   | 各バイトデータのXORをとってCRCを|
|      |                   |                  | 作っておく。最初は0x00とXORする |
+------+-------------------+------------------+---------------------------------+
| N+1  | CRC               |                  |                                 |
+------+-------------------+------------------+---------------------------------+
| N+2  |                   | ACK = 0x06       |                                 |
+------+-------------------+------------------+---------------------------------+

mbed視点で見ると、

1. LocalFileSystemに580用のバイナリを用意しておく
1. バイナリファイルのサイズを確認して変数に入れておく
1. `DA14580`をリセットさせる
1. 0x02を受け取るまで待つ(タイムアウトを設定しておく)
    1. 受け取ったら0x01、ファイルサイズ(LSB,MSBの順)を返送する
    1. 1バイト受け取るまで待つ(タイムアウトを設定しておく)
        1. 受け取ったものがACKならバイナリファイルを先頭から送る
        1. このとき各バイトのXORをとる(`ローカルCRC`)。最初は0x00とのXORをとる。
        1. 全て送ったあとCRCの返送を待つ(`リモートCRC`)
        1. `ローカルCRC`と`リモートCRC`が一致したらACKを送って書き込み成功  

となります。

#### mbedへの実装{.unnumbered}

mbed LPC1768用の実装例を示します。`file_size()`のみオリジナルのイカ醤油ポッポ焼きから移植しました：  

~~~~ {#main.cpp .c .numberLines numbers="left"}
/*
mbed LPC1768のLocalFileSystem上にあるtarget_binというファイルを
UARTブートローダを使ってDA14580に流し込む
*/
#include "mbed.h"

DigitalOut myled( LED1 );   /*ブート完了インジケータLED*/
Serial pc( USBTX, USBRX );  /*PCとのシリアル通信*/
Serial ble( p9, p10 );      /*DA14580とのシリアル通信*/

/*LocalFileSystemを使う宣言*/
LocalFileSystem local( "local" );

/*使いませんが残しておきます。セカンダリブートローダという体です*/
#define     SOURCE_FILE         "/local/loader_bin"

/*アプリケーションバイナリの定義*/
#define     TARGET_FILE         "/local/target_bin"

/*ファイルサイズを測る関数のプロトタイプ宣言*/
int file_size( FILE *fp );

/*XMODEM風ブートプロトコルで使われる定数*/
enum XMODEM_CONST{
SOH = (0x01),
STX = (0x02),
EOT = (0x04),
ACK = (0x06),
DLE = (0x10),
NAK = (0x15),
CAN = (0x18),
};

int main()
{
    uint8_t recieve;    /*DA14580から送られてくるデータ*/
    uint8_t read;       /*ファイルから1バイトずつ読みだす*/
    int filesize = 0;   /*アプリケーションバイナリのファイルサイズ*/
    FILE* fp;           /*よくあるファイルポインタの宣言*/
    ble.baud( 57600 );  /*57600baudでUART通信*/
    int crc = 0x00;     /*CRCの初期値*/

    /*ファイルを開いてサイズを取得（まだ閉じない）*/
    fp = fopen( TARGET_FILE, "rb" );
    if ( fp ) {
        filesize = file_size( fp );
        pc.printf( "0x%04X\n\r", filesize );
    }

    /*DA14580からのSTXを受け取り即座にSOHを返す*/
    while( 1 ) {
        recieve = ble.getc();
        if( recieve == STX ) {
            ble.putc( SOH );
            pc.putc( '!' );
            break;
        }
    }
    /*バイナリのサイズを知らせる*/
    ble.putc( filesize & 0xff );
    ble.putc( (filesize >> 8) & 0xff );

    /*DA14580からのACKを待つ*/
    while( 1 ) {
        recieve = ble.getc();
        if( recieve == ACK ) {
            pc.printf( "ok!\n\r" );
            break;
        }
    }

    /*アプリケーションバイナリを送る*/
    for(int i = 0; i < filesize; i++){
        read = getc( fp );  /*1byte読み込み。ポインタが自動的に1バイト分進みます*/
        ble.putc( read );   /*読み込んだ1バイトを送信*/
        crc = crc ^ read;   /*CRCを計算*/
        if( (i % 16) == 0 ){
            pc.printf( "\n\r" );
        }
        pc.printf( "%02X ", read );
    }
    pc.printf( "\n\r0x%02X ", crc );

    /*DA14580からCRCを受け取り、一致していればACKを返して完了*/
    while(1) {
        recieve = ble.getc();
        if( recieve == crc ) {
            ble.putc( ACK );
            pc.printf( "-=-=DONE=-=-\n\r" );
            break;
        }
    }
    fclose( fp ); /*ファイルを閉じる*/
    myled = 1;    /*ブート完了インジケータLEDを点灯*/

    /*以下USBシリアル変換として振る舞います*/
    while( 1 ) {
        recieve = ble.getc();
        pc.putc( recieve );
        wait_ms( 20 );
    }
}

/*ファイルサイズ計測関数*/
int file_size( FILE *fp )
{
    int     size;

    fseek( fp, 0, SEEK_END ); // seek to end of file
    size    = ftell( fp );    // get current file pointer
    fseek( fp, 0, SEEK_SET ); // seek back to beginning of file

    return size;
}

~~~~

[^2_3_1]: https://developer.mbed.org/users/okano/notebook/how_the_ika_shouyu_poppo_yaki_born/
[^2_3_2]: https://developer.mbed.org/users/okano/code/ika_shouyu_poppoyaki/wiki/Homepage
